# coding: utf-8

"""
    CEIC API

    CEIC API v2 is a new generation RESTful API that provides an easy access to CEIC's analytical and time series information, including all metadata items and time point values. It includes powerful keyword and criteria search, as well as a data feed option – retrieving only the newest time points data, in order to feed user’s own database and compare the actual changes introduced. Supported output formats include XML, JSON and CSV.  API access is secured utilizing API keys and all data transfer encrypted via HTTPS. In order to use any of the API functions, users shall generate such a key. This can be done through user's profile menu under CDMNext. Users can have only one active API key. Generating a new key will invalidate the existing one. API keys have to be included with each HTTP request, either as an `Authorization` header or as `token` query parameter.  All dates for both input parameters and output attributes are in ISO 8601 format (YYYYMMDD or YYYY-MM-DD) in order to avoid misinterpretation of numeric representations of dates and times, particularly when data are transferred between countries with different conventions for writing numeric dates and times.  <p style=\"color: red\">Security Notice: As of June 30, 2018 the CEIC API v2 will not be accessible by clients using SSL or TLS 1.0 security protocol</p>  <ul>         <li>             <a href='https://developer.isimarkets.com/en/CEIC/PythonSdk/FullDevGuide'>CEIC Python SDK - Development Guide</a>         </li>         <li>             <a href='https://developer.isimarkets.com/en/CEIC/PHPSdk/FullDevGuide'>CEIC PHP SDK - Development Guide</a>         </li>         <li>             <a href='https://developer.isimarkets.com/en/CEIC/JavascriptSdk/FullDevGuide'>CEIC JavaScript SDK - Development Guide</a>         </li>     <li>   <a href='https://downloads.ceicdata.com/api/documentation/api-release-notes.html'>Release Notes</a>   <span>             <a href=\"https://downloads.ceicdata.com/api/documentation/api-release-notes-rss.xml\">                 <img src=\"https://downloads.ceicdata.com/api/documentation/release-notes-files/rss-logo-rectangle-35x75.png\">             </a>         </span>     </li>  </ul>  <div>     <a href='https://api-status.ceicdata.com/'>Monitor CEIC API Status</a> </div>  # noqa: E501

    OpenAPI spec version: 2.8.11
    Contact: helpdesk@ceicdata.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class ResponseError(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'status': 'int',
        'message': 'str',
        'code': 'str'
    }

    attribute_map = {
        'status': 'status',
        'message': 'message',
        'code': 'code'
    }

    def __init__(self, status=None, message=None, code=None):  # noqa: E501
        """ResponseError - a model defined in Swagger"""  # noqa: E501

        self._status = None
        self._message = None
        self._code = None
        self.discriminator = None

        if status is not None:
            self.status = status
        self.message = message
        self.code = code

    @property
    def status(self):
        """Gets the status of this ResponseError.  # noqa: E501

        The error status  # noqa: E501

        :return: The status of this ResponseError.  # noqa: E501
        :rtype: int
        """
        return self._status

    @status.setter
    def status(self, status):
        """Sets the status of this ResponseError.

        The error status  # noqa: E501

        :param status: The status of this ResponseError.  # noqa: E501
        :type: int
        """

        self._status = status

    @property
    def message(self):
        """Gets the message of this ResponseError.  # noqa: E501

        The error message  # noqa: E501

        :return: The message of this ResponseError.  # noqa: E501
        :rtype: str
        """
        return self._message

    @message.setter
    def message(self, message):
        """Sets the message of this ResponseError.

        The error message  # noqa: E501

        :param message: The message of this ResponseError.  # noqa: E501
        :type: str
        """
        if message is None:
            raise ValueError("Invalid value for `message`, must not be `None`")  # noqa: E501
        allowed_values = ["Sorry, some error happened. We are checking the problem.", "Unsupported data format. Only {FORMATS_STRING} are supported", "Unsupported data format for this request. This request can return only {FORMATS_STRING} formats", "Sorry, we could not find the page that you requested. Please check API documentation.", "One or more input parameters are invalid. Please check API documentation.", "Sorry, you have not rights to use this API method.", "Please reduce number of series requested or number of timepoints retrieved (apply time-points filters).", "We can't process your request  during 30s. Payload too large or server overloaded. Please reduce number of series requested or number of timepoints retrieved (apply time-points filters).", "This method is not available yet.", "Your subscription does not include this service", "CAS communication error", "Unhandled CAS error", "Please use access token to get data", "No api access for mentioned user", "Api key is invalid", "Credentials are incorrect", "Please use application login to get session id", "Please use application password to get session id", "Pleas provide application to use API", "Series `{id}` not found", "Your current subscriptions do not include the `{id}` series.", "Filter('s) `{keys}` is(are) not supported.", "You can get more than `{limit}` series per search request. Please use `offset` parameter to get more than `{limit}` series", "You can get more than `{limit}` series per one request.", "Currently search does not support filter with list of if's and search criteria", "Minimum image size is {size}. Please change width/height on request parameters", "Maximum image size is {size}. Please change width/height on request parameters", "Incorrect period mask", "`period` and `start_date`/`end_date` are interchangeable. Please use one of them", "You cannot have more than {count} series in a series list, when using search.", "Insights `{id}` not found", "Your current subscriptions do not include the `{id}` insight.", "Your have no permissions to open `{id}` insight.", "Insight series with `{id}` not found`", "Series data for `{id}` can not be loaded", "For now download for this kind of insights does not supported.", "Requested insight does not contain downloadable visuals.", "Series with `{id}` not more supported.`", "You can get more than `{limit}` insights per search request. Please use `offset` parameter to get more than `{limit}` insights", "This insight can't be downloaded as XLSX", "You can't download insight without series as XLSX", "We are generating your insight document. Please try to get this document later to get download link.", "You can download insight only as '{INSIGHT_DOWNLOAD_FORMATS}'", "Filter with id: `{id}` not found", "You can't request series and filter parameters.", "Impossible to create empty filter. Please set some search parameters.", "Some of the requested filters could not be deleted since they are used in feeds. Filter IDs: {ids}", "You cannot have more than {count} series in a filter.", "Please specify `filter` GET parameter", "Please check data dump `id`", "Dump is generating. Use `GET` request to get information about generating process", "Max number of dumps are already generating for current user.", "Impossible to create dump without series", "At least one notification method must be specified.", "Exactly one database must be specified, when using search filters for feeds/dumps.", "`offset` value must be greater than 0.", "Value for the `limit` parameter must be between 1 and 100.", "{INPUT_FREQUENCY_VALUE} is invalid frequency value for notifications. The supported frequencies are {FREQUENCIES_STRINGS}", "Impossible to process watchlist subscription. Series list is empty.", "Cannot process watchlist subscription. Series {NON_EXISTING_SERIES} does not exist", "Cannot process watchlist subscription. Please select a notification method."]  # noqa: E501

        message = self._parse_enum_value(message, allowed_values)
        if message not in allowed_values:
            raise ValueError(
                "Invalid value for `message` ({0}), must be one of {1}"  # noqa: E501
                .format(message, allowed_values)
            )

        self._message = message

    @property
    def code(self):
        """Gets the code of this ResponseError.  # noqa: E501

        The error code  # noqa: E501

        :return: The code of this ResponseError.  # noqa: E501
        :rtype: str
        """
        return self._code

    @code.setter
    def code(self, code):
        """Sets the code of this ResponseError.

        The error code  # noqa: E501

        :param code: The code of this ResponseError.  # noqa: E501
        :type: str
        """
        if code is None:
            raise ValueError("Invalid value for `code`, must not be `None`")  # noqa: E501
        allowed_values = ["INTERNAL_SERVER_ERROR", "UNSUPPORTED_RESPONSE_FORMAT", "UNSUPPORTED_CONTROLLER_FORMAT", "NOT_FOUND_API_PATH", "INVALID_INPUT_PARAMETER", "HAVE_NO_PERMISSIONS", "PAYLOAD_TOO_LARGE", "RESPONSE_TIMEOUT", "NOT_IMPLEMENTED", "UNSUBSCRIBED_SERVICE", "CAS_COMMUNICATION_ERROR", "CAS_ERROR", "MISSED_API_TOKEN", "NO_API_ACCESS", "INVALID_API_TOKEN", "INCORRECT_CREDENTIALS", "MISSED_USER_LOGIN", "MISSED_USER_PASSWORD", "MISSED_USER_APPLICATION", "SERIES_NOT_FOUND", "UNSUBSCRIBED_SERIES", "INVALID_SEARCH_FILTER", "INVALID_SEARCH_LIMIT", "INVALID_ENTITIES_LIMIT", "UNSUPPORTED_FILTER", "MIN_IMAGE_SIZE", "MAX_IMAGE_SIZE", "INCORRECT_PERIOD", "INTERCHANGEABLE_PARAMETERS", "MAX_SERIES_LIST_COUNT", "INSIGHT_NOT_FOUND", "UNSUBSCRIBED_INSIGHT", "INSIGHT_PERMISSIONS", "INSIGHT_SERIES_NOT_FOUND", "SERIES_DATA_CAN_NOT_BE_LOADED", "UNSUBSCRIBED_INSIGHT_SERIES", "IMPOSSIBLE_TO_DOWNLOAD", "EMPTY_VISUALS", "INSIGHT_SERIES_NOT_SUPPORTED", "EXCEL_GENERATION_ERROR", "EMPTY_SERIES_XLSX_DOWNLOAD_ERROR", "INSIGHT_GENERATION_TIMEOUT", "UNSUPPORTED_INSIGHT_FILE_FORMAT", "FILTER_NOT_FOUND", "FILTER_MIXED_PARAMETERS", "EMPTY_FILTER", "FILTER_USED", "MAX_FILTER_SERIES_LIST_COUNT", "MISSED_FILTER_PARAMETER", "REQUESTED_DATA_DUMP_NOT_FOUND", "DUMP_IS_GENERATING_FOR_REQUESTED_FILTER", "DUMPS_ARE_GENERATING_FOR_REQUESTED_USER", "DUMP_IS_GENERATING_FOR_REQUESTED_FEED", "EMPTY_DUMP_CAN_NOT_BE_CREATED", "NOTIFICATION_METHOD_NOT_SELECTED", "INVALID_DATABASES_COUNT", "INVALID_OFFSET_PARAMETER", "INVALID_LIMIT_PARAMETER", "UNSUPPORTED_WATCHLIST_NOTIFICATION_FREQUENCY", "EMPTY_SERIES_LIST", "NON_EXISTING_SERIES", "EMPTY_WATCHLIST_METHOD"]  # noqa: E501

        code = self._parse_enum_value(code, allowed_values)
        if code not in allowed_values:
            raise ValueError(
                "Invalid value for `code` ({0}), must be one of {1}"  # noqa: E501
                .format(code, allowed_values)
            )

        self._code = code

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    @staticmethod
    def _parse_enum_value(value, enum_values):
        for enum_value in enum_values:
            if str(value).lower() == str(enum_value).lower():
                value = enum_value

        return value

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, ResponseError):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
